<!DOCTYPE html>
<html lang="en">

<head>
    <!-- basic -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <!-- mobile metas -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="viewport" content="initial-scale=1, maximum-scale=1">
    <!-- site metas -->
    <title>Unidad 1</title>
    <link rel="icon" type="image/x-icon" href="images/favicon.ico">
    <meta name="keywords" content="">
    <meta name="description" content="">
    <meta name="author" conxtent="">
    <!-- bootstrap css -->
    <link rel="stylesheet" type="text/css" href="css/bootstrap.min.css">
    <!-- style css -->
    <link rel="stylesheet" type="text/css" href="css/style.css">
    <!-- Responsive-->
    <link rel="stylesheet" href="css/responsive.css">
    <!-- fevicon -->
    <link rel="icon" href="images/fevicon.png" type="image/gif" />
    <!-- Scrollbar Custom CSS -->
    <link rel="stylesheet" href="css/jquery.mCustomScrollbar.min.css">
    <!-- Tweaks for older IEs-->
    <link rel="stylesheet" href="https://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css">
    <!-- owl stylesheets -->
    <link rel="stylesheet" href="css/owl.carousel.min.css">
    <link rel="stylesheet" href="css/owl.theme.default.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.5/jquery.fancybox.min.css" media="screen">

</head>
<!-- body -->

<body class="about_page">
    <div class="header_main">
        <div class="container">
            <div class="logo">
                <a href="../index.html"><img src="../images/logo.svg" height="100"></a>
            </div>
        </div>
    </div>
    </div>
    <div class="header">
        <div class="container">
            <!--  header inner -->
            <div class="col-sm-12">

                <div class="menu-area">
                    <nav class="navbar navbar-expand-lg ">
                        <!-- <a class="navbar-brand" href="#">Menu</a> -->
                        <button class="navbar-toggler collapsed" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
                       <i class="fa fa-bars"></i>
                        </button>
                        <div class="collapse navbar-collapse" id="navbarSupportedContent">
                            <ul class="navbar-nav mr-auto">
                                <li class="nav-item active">
                                    <a class="nav-link" href="../index.html">Home<span class="sr-only">(current)</span></a>
                                </li>
                                <li class="nav-item active">
                                    <div class="btn-group">
                                        <a class="nav-link dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" href="unidad_uno.html">Unidad 1</a>
                                        <div class="dropdown-menu">
                                            <a class="dropdown-item" href="unidad_uno.html">1.1 - Modelos de arquitecturas</a>
                                            <a class="dropdown-item" href="unidad_uno-dos.html">1.2 - Análisis de componentes</a>
                                            <a class="dropdown-item" href="unidad_uno-dos-dos.html">1.2.2 - Memoria</a>
                                            <a class="dropdown-item" href="unidad_uno-dos-tres.html">1.2.3 - Manejo de la entrada/salida</a>
                                            <a class="dropdown-item" href="unidad_uno-dos-cuatro.html">1.2.4 - Buses</a>
                                        </div>
                                    </div>
                                </li>
                                <li class="nav-item">
                                    <div class="btn-group">
                                        <a class="nav-link dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" href="unidad_uno.html">Unidad 2</a>
                                        <div class="dropdown-menu">
                                            <a class="dropdown-item" href="unidad_dos.html">2.1 - Organización del procesador</a>
                                            <a class="dropdown-item" href="unidad_dos-dos.html">2.2 - Estructura de Registros</a>
                                            <a class="dropdown-item" href="unidad_dos-tres.html">2.3 - Ciclo de instricción</a>
                                            <a class="dropdown-item" href="unidad_dos-cuatro.html">2.4 - Caso de estudio de CPU reales</a>
                                        </div>
                                    </div>
                                </li>
                                <li class="nav-item">
                                    <div class="btn-group">
                                        <a class="nav-link dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" href="unidad_uno.html">Unidad 3</a>
                                        <div class="dropdown-menu">
                                            <a class="dropdown-item" href="unidad_tres.html">3.1 - Chip Set</a>
                                            <a class="dropdown-item" href="unidad_tres-dos.html">3.2 - Aplicaciones</a>
                                            <a class="dropdown-item" href="unidad_tres-tres.html">3.3 Ambientes de Servicio</a>
                                        </div>
                                    </div>
                                </li>
                                <li class="nav-item">
                                    <div class="btn-group">
                                        <a class="nav-link dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" href="unidad_uno.html">Unidad 4</a>
                                        <div class="dropdown-menu">
                                            <a class="dropdown-item" href="unidad_cuatro.html">4.1 - Computación Paralela</a>
                                            <a class="dropdown-item" href="unidad_cuatro-dos.html">4.2 - Tiposde Computación Paralela</a>
                                            <a class="dropdown-item" href="unidad_cuatro-tres.html">4.3 - Sistemas de Memoria Compartida</a>
                                            <a class="dropdown-item" href="unidad_cuatro-cuatro.html">4.4 - Sistemas de Memoria Distribuida</a>
                                            <a class="dropdown-item" href="unidad_cuatro-cinco.html">4.5 - Casos de Estudio</a>
                                        </div>
                                    </div>
                                </li>
                            </ul>
                        </div>
                    </nav>
                </div>
            </div>
        </div>
    </div>
    <!-- end header end -->
    <!--services start -->
    <div class="about_main">
        <div class="services_main">
            <div class="container">
                <div class="creative_taital">
                    <h1 class="creative_text">1.2.3: Manejo de la entrada/salida</h1>
                    <p style="color: #050000;">
                        En el desempeño de los dispositivos de E/S se necesita, incorporar 2 nuevos términos: Buffering (uso de memoria intermedia). El buffering trata de conservar ocupados tanto la CPU como los dispositivos de E/S. La iniciativa es fácil, los datos se leen
                        y se almacenan en un buffer, cuando los datos se han leído y la CPU va a empezar velozmente la operación con ellos, el dispositivo de ingreso es instruido para comenzar velozmente la siguiente lectura. La CPU y el dispositivo de
                        acceso están ocupados. Una vez que la CPU se encuentre independiente para el siguiente conjunto de datos, el dispositivo de acceso habrá culminado de leerlos. La CPU va a poder comenzar el proceso de los últimos datos leídos, a
                        medida que el dispositivo de acceso empezará la lectura de los datos siguientes. Para la salida, el proceso es similar. En esta situación los datos de salida se descargan en otro buffer hasta que el dispositivo de salida logre
                        procesarlos. Este sistema soluciona en forma parcial el problema de conservar ocupados a todas horas la CPU y los dispositivos de E/S. Debido a que todo es dependiente del tamaño del buffer y de la rapidez de procesamiento tanto
                        de la CPU como de los dispositivos de E/S.
                    </p>
                    <p style="color: #050000;">
                        MÓDULOS DE ENTRADA
                    </p>
                    <p style="color: #050000;">
                        Dichos dispositivos permiten al cliente de la computadora incorporar datos, comandos y programas en el CPU. El dispositivo de ingreso más común es un teclado parecido al de las máquinas de redactar. La información introducida con el mismo, es transformada
                        por el ordenador en modelos reconocibles. Los datos se leen de los dispositivos de acceso y se almacenan en la memoria central o interna. Los Dispositivos de Acceso, transforman la información en señales eléctricas que se almacenan
                        en la memoria central.
                    </p>
                    <p style="color: #050000;">
                        MÓDULOS DE SALIDA
                    </p>
                    <p style="color: #050000;">
                        Dichos dispositivos permiten al cliente ver los resultados de los cálculos o de las manipulaciones de datos del computador. El dispositivo de salida más común es la unidad de visualización (VDU, acrónimo de Clip de video Display Unit), que se apoya en
                        un monitorque muestra los letras y números y gráficos en una pantalla semejante a la del televisor.
                    </p>
                    <p style="color: #050000;">
                        ENTRADA/SALIDA PROGRAMADA
                    </p>
                    <p style="color: #050000;">
                        La entrada-salida programada (también ingreso / salida programada , E / S programada , PIO ) es un procedimiento de transmisión de datos , por medio de ingreso / salida (E / S), entre una unidad central de procesamiento (CPU) y un dispositivo periférico
                        , como un adaptador de red o un dispositivo de almacenamiento Parallel ATA (PATA, previamente AT Attachment (ATA)). Cada transferencia de recursos de datos se inicia por medio de una instrucción en el programa, que implica a la
                        CPU para cada transacción. Por otro lado, en las operaciones de ingreso directo a memoria (DMA), la CPU no participa en la transferencia de datos. El concepto puede referirse a E / S mapeadas en memoria (MMIO) o E / S mapeadas
                        en puertos (PMIO). PMIO tiene relación con transferencias que usan un lugar de direcciones particular fuera de la memoria usual, al que principalmente se accede con normas dedicadas, comoEN y FUERAen arquitecturas x86 . MMIO tiene
                        relación con transferencias a dispositivos de E / S que permanecen mapeados en el espacio de direcciones usual disponible para el programa. PMIO ha sido bastante eficaz para los primeros microprocesadores con espacios de direcciones
                        pequeños, debido a que los dispositivos de E / S no consumían el importante recurso.
                    </p>
                    <p style="color: #050000;">
                        ENTRADA/SALIDA MEDIANTE INTERRUPCIONES
                    </p>
                    <p style="color: #050000;">
                        El problema con E/S programada es que el CPU tiene que esperar un tiempo considerable a que el módulo de E/S en cuestión esté preparado para recibir o transmitir los datos. El CPU debe estar comprobando continuamente el estado del módulo de E/S. Se degrada
                        el desempeño del sistema. Una alternativa es que el CPU tras enviar una orden de E/S continué realizando algún trabajo útil. El módulo de E/S interrumpirá al CPU para solicitar su servicio cuando esté preparado para intercambiar
                        datos. El CPU ejecuta la transferencia de datos y después continúa con el procesamiento previo.
                    </p>
                    <p style="color: #050000;">
                        La E/S con interrupciones, aunque más eficiente que la E/S programada, también requiere la intervención del CPU para transferir datos entre la memoria y el módulo de E/S. En el caso de la entrada/salida por interrupciones, es el dispositivo quien establece
                        el momento en que se realiza la transferencia de los datos, avisando a la CPU de que ha ocurrido un evento (por ejemplo, que el usuario haya presionado una tecla). En este punto, debemos aclarar que en la familia 80x86 existen
                        tres tipos de interrupciones, que a veces producen confusi´on por la nomenclatura empleada en diversos textos:

                    </p>
                    <p style="color: #050000;">
                        Para cada tipo de interrupci´on, por tanto, se puede instalar una rutina de atenci´on o servicio de interrupci´on. Cuando la CPU recibe notificaci´on de la interrupci´on detiene el programa en ejecuci´on, ejecuta la ISR (es decir, sirve al dispositivo
                        haciendo que cese su petici´on de interrupci´on y finalmente devuelve el control al programa, restaurando su estado anterior. Por tanto, una condici´on importante a cumplir es que una ISR debe preservar el estado del procesador
                        (el contenido de todos sus registros) para poder volver al estado anterior a la llamada
                    </p>
                    <p style="color: #050000;">
                        ACCESO DIRECTO A MEMORIA
                    </p>
                    <p style="color: #050000;">
                        El DMA (acceso directo a la memoria) posibilita que el dispositivo de red mueva los datos del paquete de manera directa a la memoria del sistema, disminuyendo la implementación de la CPU. No obstante, la frecuencia y los intervalos aleatorios en los que
                        los paquetes llegan no permiten que el sistema ingrese un estado de energía más bajo. El coalescentes DMA posibilita que el NIC recoja los paquetes anterior a que comience un acontecimiento DMA. Esto puede incrementar la latencia
                        de la red, sin embargo además se incrementa las probabilidades de que el sistema consuma menos energía. Los adaptadores y dispositivos de red basados en el controlador Ethernet Intel® I350 (y controladores posteriores) Ayuda la
                        fusión de DMA
                    </p>
                    <p style="color: #050000;">
                        CANALES Y PROCESADORES DE ENTRADA/SALIDA
                    </p>
                    <p style="color: #050000;">
                        Los periféricos no se conectan de manera directa al sistema de buses, para conseguir a la CPU y la memoria (salvo cualquier caso especial), por distintos motivos. Los periféricos resultan muy diferentes entre sí, y debe disponerse de una lógica adicional
                        en la CPU para cada dispositivo. Además, la mayor parte de los periféricos son lentos en relación a la CPU y la memoria, por lo cual se desaprovecharía tiempo y prestaciones conectándolos a un sistema de buses de alta rapidez.
                        Además es problema que la CPU y la memoria gestionen las transferencias de ciertos periféricos de bastante elevados rendimientos. Al final, los periféricos son diversos constructivamente, y usan datos con formatos y tamaños diversos
                        a los del computador con la que se comunican. Los periféricos se comunican a la PC por medio de un enlace a un módulo de E/S específico. El enlace posibilita el trueque de señales de control, de estado y los datos entre el módulo
                        de E/S y el dispositivo externo. Con las señales de control se establece la funcionalidad que debería hacer el periférico. Mientras tanto que con las señales de estado se sugiere el estado del dispositivo, ejemplificando, para
                        señalar si está preparado o no para una transferencia. Al final, con los datos se genera el efectivo trueque de la información digital que se envía o obtiene a partir del módulo de E/S.
                    </p>
                </div>
            </div>
        </div>
    </div>




    <div class="copyright">
        <div class="container">
            <div class="row">
                <div class="col-sm-12">
                    <ul>
                        <li style="float: left; padding-left: 16px;">
                            <a href="https://www.facebook.com/jona.perez.927/" target="_blank">
                                <i class="fa fa-facebook fa-2x" aria-hidden="true"></i>
                            </a>
                        </li>
                        <li style="float: left; padding-left: 16px;">
                            <a href="https://www.instagram.com/jonap9.8/" target="_blank">
                                <i class="fa fa-instagram fa-2x" aria-hidden="true"></i></i>
                            </a>
                        </li>
                        <li style="float: left; padding-left: 16px;">
                            <a href="https://github.com/Jonap98?tab=repositories" target="_blank">
                                <i class="fa fa-github fa-2x" aria-hidden="true"></i></i>
                            </a>
                        </li>
                        <li>
                            <span style="color: #fff; padding-left: 16px; font-size: medium;">Jonathan Isaí Pérez López
                                <a href="mailto:l17050547@saltillo.tecnm.mx">17050547</span>
                            </p>
                        </li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
    <!-- Javascript files-->
    <script src="js/jquery.min.js"></script>
    <script src="js/popper.min.js"></script>
    <script src="js/bootstrap.bundle.min.js"></script>
</body>

</html>